<?xml version="1.0"?>
<!--
  Program UI package for use with TAME

  Copyright (C) 2017, 2018 R-T Specialty, LLC.

    This file is part of the Liza Program UI Compiler.

    liza-proguic is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see
    <http://www.gnu.org/licenses/>.
-->
<stylesheet version="2.0"
  xmlns="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:lv="http://www.lovullo.com/rater"
  xmlns:lvp="http://www.lovullo.com"
  xmlns:assert="http://www.lovullo.com/assert"
  xmlns:c="http://www.lovullo.com/calc"
  xmlns:t="http://www.lovullo.com/rater/apply-template">

<import href="expand.xsl" />


<output method="xml"
        indent="yes" />

<!--
  A package will be generated representing a respective UI
  definition.  The purpose of this package is to provide tight
  integration with the rest of the system, taking advantage of its
  functionality and built-in error checking.
-->
<template match="lvp:program"
          as="element( lv:package )"
          priority="5">
  <lv:package title="Program UI Param and Class Definitions">
    <!-- intentional whitespace -->
    <comment>
      WARNING: Do NOT modify this file!
      It is auto-generated by progui-pkg.
    </comment>

    <sequence select="lvp:gen-params( //lvp:question )" />
    <apply-templates />

    <lv:template name="_gen-progui-aggregate_"
                 desc="Generate progui aggregate class">
      <lv:classify as="--progui-classes" yields="__proguiClasses"
                   desc="Aggregate of all progui classes for easy mapping;
                         the yield is nonsense">
        <lv:inline-template>
          <lv:for-each>
            <lv:sym-set name-prefix="--vis-" type="class" />
            <lv:sym-set name-prefix="--set-" type="class" />
          </lv:for-each>

          <t:match-class>
            <attribute name="name" select="'{@sym_name@}'" />
          </t:match-class>
        </lv:inline-template>
      </lv:classify>
    </lv:template>

    <!-- using a template to get around some odd preproc issue with
         expanding inline-template with sym-set outside of a parent
         template -->
    <t:gen-progui-aggregate />
  </lv:package>
</template>


<function name="lvp:gen-params">
  <param name="questions" as="element( lvp:question )*" />

  <for-each select="$questions">
    <lv:param name="ui_q_{@id}"
              type="integer"
              desc="Auto-generated by progui-pkg">
      <if test="not( @dim = '0' )">
        <attribute name="set" select="'vector'" />
      </if>
    </lv:param>
  </for-each>
</function>


<!--
  UI import directives are translated essentially verbatim (namespace
  change only) into DSL imports; they must be used to import the
  packages necessary to satisfy any predicates.
-->
<template match="lvp:import"
          as="element( lv:import )"
          priority="5">
  <lv:import>
    <sequence select="@*|*" />
  </lv:import>
</template>


<!--
  UI steps are translated into sections purely for organization and
  context retention through step titles.

  Groups are handled in the same manner.
-->
<template match="lvp:step|lvp:group"
          as="element( lv:section )"
          priority="5">
  <variable name="title" as="xs:string"
            select="if ( not( @title ) or @title = '' ) then
                    '(Untitled)'
                    else
                    @title" />

  <lv:section title="{$title}">
    <apply-templates />

    <!-- it's okay that we generate this for every one, since unreferenced
         ones won't be compiled into the UI -->
    <for-each select="lvp:question">
      <variable name="id" as="xs:string"
                select="lvp:qid-to-class( @id )" />

      <lv:classify as="--set-{$id}"
                   desc="{local-name()} {@id} is set"
                   keep="true">
        <t:match-gt on="ui_q_{@id}" value="#0" />
      </lv:classify>
    </for-each>
  </lv:section>
</template>


<!--
  Predicates are provided to a number of objects in the UI through a
  @code{@@when} attribute.  These will be converted directly into
  classifications that will yield whether the predicate has matched
  for that object.
-->
<template match="lvp:question[ @when ]
                 |lvp:display[ @when ]
                 |lvp:static[ @when ]
                 |lvp:option[ @when ]"
          priority="5">
  <variable name="self" as="element()"
            select="." />

  <variable name="id" as="xs:string"
            select="if ( @id ) then @id else @ref" />
  <variable name="cid" as="xs:string"
            select="lvp:qid-to-class( $id )" />

  <lv:classify as="--vis-{$cid}"
               desc="{local-name()} {@id} is visible"
               keep="true">
    <for-each select="lvp:predicate">
      <for-each select="lvp:expand-pred( $self, . )">
        <t:match-class name="{.}" />
      </for-each>
    </for-each>
  </lv:classify>

  <apply-templates />
</template>


<!--
  Assertions can reference classifications using the `c:*'
  syntax.  The purpose of generating classifications here is to force
  the dependencies to be linked.
-->
<template match="assert:*[ starts-with( @ref, 'c:' ) ]"
          priority="5">
  <variable name="parent-id" as="xs:string"
            select="translate( ancestor::lvp:question/@id,
                               '_', '-' )" />
  <variable name="class-name" as="xs:string"
            select="substring-after( @ref, 'c:' )" />

  <variable name="unique" as="xs:string"
            select="generate-id(.)" />


  <lv:classify as="--vis-{$parent-id}-{$unique}"
               desc="{$parent-id} assertion predicate is applicable"
               keep="true">
    <t:match-class name="{$class-name}" />
  </lv:classify>

  <apply-templates />
</template>


<function name="lvp:qid-to-class" as="xs:string">
  <param name="id" as="xs:string" />

  <sequence select="translate(
                      $id,
                      '_ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                      '-abcdefghijklmnopqrstuvwxyz' )" />
</function>


<function name="lvp:expand-pred" as="xs:string*">
  <param name="src"  as="element()" />
  <param name="pred" as="element( lvp:predicate )" />

  <variable name="root" as="document-node( element( lvp:program ) )"
            select="root( $src )" />

  <choose>
    <!-- standard predicate; use verbatim (note that, if there is no
         colon, both type and name will be empty)  -->
    <when test="$pred/@type = 'c'">
      <sequence select="$pred/@name" />
    </when>

    <!-- inherit predicates of referenced questions -->
    <when test="$pred/@type = 'q'">
      <variable name="qnode" as="element()?"
                select="$root//lvp:question[ @id=$pred/@ref ],
                        $root//lvp:calc[ @id=$pred/@ref ]" />

      <if test="not( $qnode )">
        <message terminate="yes"
                 select="concat(
                           'error: unknown qwhen reference ',
                           $pred/@ref, ' by ',
                           $src/@id )" />
      </if>

      <variable name="qpreds" as="element( lvp:predicate )*"
                select="$qnode/lvp:predicate" />

      <for-each select="$qpreds">
        <sequence select="lvp:expand-pred( $qnode, . )" />
      </for-each>

      <!-- and assert against the value of the reference -->
      <sequence select="concat( '--set-',
                                lvp:qid-to-class( $pred/@ref ) )" />
    </when>

    <!-- unknown -->
    <otherwise>
      <message terminate="yes"
               select="concat(
                         'error: unknown predicate type `',
                         $pred/@type, '` used by ',
                         $src/@id )" />
    </otherwise>
  </choose>
</function>


<!--
  Copy all nodes in the DSL's namespace verbatim
-->
<template match="lv:*" priority="5">
  <copy-of select="." />
</template>


<!--
  All unrecognized semantic elements are ignored.
-->
<template match="node()"
          priority="1">
  <apply-templates />
</template>

</stylesheet>

